= Sorcellerie en Java : outrepasser les interdits avec sun.misc.Unsafe
:toc:
:toclevels: 3
:toc-placement: preamble
:lb: pass:[<br> +]
:imagesdir: ./images
:icons: font
:source-highlighter: highlightjs

By Thomas SCHWENDER (Softeam StarTECH Java)

== Overview

Quicky visant à présenter cette classe qui a fait couler beaucoup d’encre dernièrement (menace de suppression du jdk, levée de bouclier d’Hazelcast et d’Azul Systems, etc.) au travers :

* d’exemples précis (instantiation, création d’instance sans constructeur, sérialisation, tableaux extra larges, etc.)
* et en présentant l’usage qui en est fait par plusieurs grandes sociétés et librairies (Mockito, Hazelcast, etc.)

== Préparation avec Jean-Christophe du 28/12/2016

Conseils :

* *arriver un peu en avance* pour tester le matériel (18h30 au plus tôt, serait l'idéal)
* faire attention à la résolution
* attention au life coding !
* prévoir tout en local pour la présentation -> sur poste, sur GitHub, sur clé USB
* possible de faire les slides en Asciidoctor, suffit d'intégrer les 1er et derniers slides du template
* faire pêter un JVM *à la fin* de la présentation (un bel écran bleu à la Windows 95)

=== Présentation du projet de Continuous Benchmarking par Khaled HAMLAOUI

Gatling > JMX > ELK +
Et WireMock également :

* intercepte toutes les requêtes GET et POST en sortie
* permet de mocker des URI, soit avec une configuration mock côté WireMock, soit avec rien, soit en connectant réellement un backoffice derrière

== Plan

. Histoire de la classe (perf, pq Java a créé cette classe), et récentes actualités (Hazelcast et Azul montent au créneau suite aux menaces de suppression d'Oracle du juillet 2015)
. Utilisation de la classe : comment l'instancier ?
. Les principaux usages (120 méthodes et 20 champs) et qui s'en sert (Azul / HazelCast / ActivePivot)
. le mot de la fin : suppression à venir de Unsafe dans Java ... X ? (mais avec garantie d'Oracle que les fonctionnalités de la classe seront réintégrées "classiquement dans le JDK")
. bien donner ses ressources, avec le repo GitHub, et parler du document de notes pour plus de détails.
. Aucune classe n'a été maltraitée durant cette présentation, par contre cette JVM... Et boom écran bleu !

== Objectifs de la présentation

* Faire comprendre ce qu'est la classe / API `sun.misc.unsafe`
* Expliquer pourquoi cette classe est annoncée comme allant être supprimée
* Expliquer en quoi cette suppression poserait problème, et donc détailler les usages actuels d'Unsafe, et qui l'utilise
* Détailler les usages les plus fréquents
* Présenter les solutions de remplacement à venir

== A ne pas oublier

En début de présentation, parmi les 1ers slides :
* donner ses coordonnées (GitHub / Twitter)
* logo StarTECH

== Oral de la présentation

Bonjour, je m'appelle Thomas SCHWENDER, et je suis développeur JAVA senior (certains diraient architecte) chez SOFTEAM Cadextan, dont j'anime également le JUG interne (-> Montrer le logo du JUG ?). +
En tant que techos, parmi mes hobbies du moment, on retrouve : jouer avec les rouages de Maven / Gradle, tripatouiller les entrailles de Git, prêcher la doc utile ("dans le wiki je crois"), ET mettre le nez dans la perf de notre langague préféré, d'où cette présentation !

Alors, comme son titre, un peu racoleur, le laisse penser, nous sommes ici pour parler de la fameuse classe / API `sun.misc.Unsafe`, expliquer pourquoi elle défraie la chronique depuis bientôt 2 ans (vous avez probablement eu vent du projet de suppression à venir), et bien sûr, vous montrer un peu comment certains grands noms de la tech utilisent sa "magie", ou plutôt sa *sorcellerie* !

Alors, pour commencer, c'est quoi que cette classe `sun.misc.Unsafe` ?

== Présentation et histoire de la classe

=== Qu'est ce que Unsafe ?

Comme tous les packages `sun.*`, Unsafe est une *internal proprietary API*. +
Ce qui veut dire qu'en principe, elle n'est censé être utilisée *que* par Oracle pour l'implémentation de *SA* plateforme Java (ce qui sous-entend HotSpot uniquement). +
Comme le rappelle le site d'Oracle :

[quote, Oracle Java FAQ]
____
The sun.* packages are not part of the supported, public interface. 
[...]
In general, writing java programs that rely on sun.* is risky: those classes are not portable, and are not supported.
____
Néanmoins, elle est techniquement utilisable par tous, mais son suivi n'est donc pas assuré par Oracle, elle n'est pas documentée, ne dispose d'aucune garantie de portabilité d'une plateforme Java à une autre, et peut être modifiée à tout moment. +
-> TODO : concernant ce dernier point, revenir dessus en parlant des méthodes intrinsified

On peut d'ailleurs noter que, depuis la sortie de Java 6, le compilateur vous avertit lorsque vous utilisez une classe de ce type :

[source, java]
----
YourClassUsingUnsafe.java:15: warning: Unsafe is internal proprietary API and may be removed in a future release
----

Mais alors pourquoi s'en servir ?

* *Avantages* : +
Principalement, pour 2 grandes raisons :

** certaines fonctionnalités d'Unsafe ne sont disponibles nulle part ailleurs dans Java : +
lecture depuis / écriture à des adresses mémoires, accès à la mémoire Off Heap, etc.

** La performance ! Quasiment toutes les méthodes d'Unsafe sont *intrinsèques* ("intrinsics" ou "intrinsified methods" en anglais), d'où des performances généralement bien meilleures que celles des méthodes "classiques". +
Qu'est-ce que une méthode intrinsèque ? 
[quote, Java Bug Database JDK-8076112]
____
Intrinsics are high optimized (mostly hand written assembler) code which are used instead of normal JIT compiled code.
____
C'est donc le JIT compiler qui, si l'optimisation est disponible, va optimiser notre code en le remplaçant par du code assembleur spécifique.

Evidemment, l'utilisation d'Unsafe n'est pas sans risque, ces méthodes très bas niveau ne respectant les barrières de sécurité classiques de Java. +
Parmi les risques encourus, on trouve, entre autres :

* violation d'accès mémoire : avec Unsafe, on peut écrire en dehors des plages mémoires allouées...
* violation de la sureté des types : avec Unsafe, on peut stocker un int dans un type référence...
* violer les contrats de méthodes : avec Unsafe, on peut faire lancer une checked exception à une méthode qui ne la déclare ou ne la catch pas...
* ou tout simplement faire crasher la JVM... en libérant la mémoire d'une plage d'adresses réservées...

=== Plan de suppression de la classe

En juillet 2015, du fait du travail sur Jigsaw visant à rendre Java plus modulaire (voir la JEP 260), Oracle a laissé entendre que l'API pourrait ne plus être directement accessible avec le JDK 9, puis définitivement supprimée avec le JDK 10. +
Le problème est que cette API, même ce n'aurait normalement pas du être le cas, est aujourd'hui utilisée par de nombreux projets et outils, et qu'elle ne dispose pas encore de véritables solutions de remplacement pour toutes ses fonctionnalités.

De plus, Oracle ne s'est pas montré très enclin à négocier sur le sujet :

[quote, Donald Smith - Oracle's director of product management]
____
Let me be blunt -- sun.misc.Unsafe must die in a fire. 
It is -- wait for it -- Unsafe. It must go.  
Ignore any kind of theoretical rope and start the path to righteousness *now*.
____

D'où la levée de boucliers de nombreuses sociétés dont Hazelcast, Azul Systems et OpenHFT pour ne citer qu'elles.

== Comment utiliser Unsafe ?

On ne peut pas instancier Unsafe directement, la classe est `final` et son constructeur privé. +
De plus, la méthode `Unsafe.getUnsafe()` est pour ainsi dire protégée, si vous l'appelez vous aurez probablement une `SecurityException`.

Donc, le plus simple pour l'instancier est d'utiliser la réflexion :

[code, java]
----
Field f = Unsafe.class.getDeclaredField("theUnsafe");
f.setAccessible(true);
Unsafe unsafe = (Unsafe) f.get(null);
----

Ou

[code, java]
----
Constructor<Unsafe> c = Unsafe.class.getDeclaredConstructor();
c.setAccessible(true);
Unsafe unsafe = c.newInstance();
----

Dans les 2 cas, vous récupérez une instance d'Unsafe, vous permettant d'accéder à ses fonctionnalités.

== Unsafe pour faire quoi, et par qui ?

* Hazelcast : High Density Memory Store

== L'avenir d'Unsafe

* One of the current suggestions is that proprietary APIs, Unsafe among them, are made accessible by passing a particular flag in the command line.
* Variables Handles (JEP 193) : cette JEP n'est pas une solution de remplacement de toute l'API, elle se concentre sur la partie d'accès à la mémoire.


== Annexes

=== Java Intrinsics

[quote, Wikipedia, Intrinsic Function]
____
In compiler theory, an intrinsic function is a function available for use in a given programming language whose implementation is handled specially by the compiler. Typically, it substitutes a sequence of automatically generated instructions for the original function call, similar to an inline function. Unlike an inline function though, the compiler has an intimate knowledge of the intrinsic function and can therefore better integrate it and optimize it for the situation. This is also called builtin function in many languages.
____

[quote, Christoph Engelbert - Technical Evangelist at Hazelcast, Intrinsic Function ]
____
Another reason for Unsafe is performance, it that almost all methods are intrinsified that means that the actual native call is never really executed but a special piece of Assembler code is injected right into the jitted Java code. This is essentially necessary if you work in the low latency space.
____

[quote, Martin Thompson - Technical Evangelist at Hazelcast, Intrinsic Function ]
____
The Unsafe method wins by a significant margin because in Hotspot, and many other JVMs, the optimiser treats these operations as intrinsics and replaces the call with assembly instructions to perform the memory manipulation.
____

[quote, Java Bug Database JDK-8076112]
____
Intrinsics are high optimized (mostly hand written assembler) code which are used instead of normal JIT compiled code.
____

[quote, Wikipedia, Intrinsic Function]
____
The HotSpot JVM's just-in-time compiler also has intrinsics for specific Java APIs.
____

[quote, http://bad-concurrency.blogspot.fr/2012/08/arithmetic-overflow-and-intrinsics.html]
____
Inside of Hotspot (other JVMs may work differently) a number of things are happening to make this work. As Hotspot loads classes it builds an abstract syntax tree (AST) representation of the Java byte code. 
When executing the Java byte code, if the interpreter notices that a particular method has been called a certain number of times2 (default is 10000) then Hotspot will look to optimise and JIT that method. 
Before optimising, the method signature will be matched against the set of predefined intrinsics, declared in vmSymbols.hpp. 
If there is a match Hotspot will replace the nodes in AST with a set of nodes specific to the intrinsic that was matched. At some later point during the compile pass of the AST, it will see the new nodes and generate the optimised machine specific assembly for that part of the tree and type of node.
____

== Resources

* code de la classe Unsafe : http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/misc/Unsafe.java?av=f

* Histoire et menaces de suppression :
** Unsafe ?! Qu'est-ce donc ? http://www.oracle.com/technetwork/java/faq-sun-packages-142232.html
** _JEP 260: Encapsulate Most Internal APIs_, la JDK Enhancement Proposal formalisant le problème, et les craintes ! (08/2015) - http://openjdk.java.net/jeps/260
** L'état des lieux de la communauté : https://docs.google.com/document/d/1GDm_cAxYInmoHMor-AkStzWvwE9pw6tnz_CebJQxuUE/edit# +
Parmi les contributeurs du document : Greg Luck (Hazelcast), Chris Engelbert (Hazelcast), Martijn Verburg (Java Champion), Ben Evans (Java Champion), Gil Tene (Azul Systems), Peter Lawrey (Java Champion), pour ne citer qu'eux...
** Menaces de suppression d'Oracle - avis d'Oracle : _"Private APIs not usable in Java 9?"_, et le fameux _"Unsafe must die in a fire"_ : http://mail.openjdk.java.net/pipermail/openjfx-dev/2015-April/017028.html
** Menaces de suppression d'Oracle - avis de Greg Luck, CEO d'Hazelcast : http://mobile.lemondeinformatique.fr/actualites/lire-java-9-la-suppression-de-l-api-sunmiscunsafe-agace-les-developpeurs-le-monde-informatique-61900.html
** Menaces de suppression d'Oracle - avis de Christoph Engelbert, Technical Evangelist d'Hazelcast : https://jaxenter.com/hazelcast-on-java-unsafe-class-119286.html +
Cite une fonctionnalité disponible uniquement via Unsafe : la lecture depuis / écriture à des adresses mémoires en Java.
** Menaces de suppression d'Oracle : https://www.infoq.com/news/2015/07/oracle-plan-remove-unsafe +
Détaille certaines des solutions de remplacement pour Unsafe
** Benchmark par Martin Thompson d'Unsafe, le gain réalisé par les méthodes "intrinsified" (intrinsèques) : https://mechanical-sympathy.blogspot.fr/2012/07/native-cc-like-performance-for-java.html +
Parle des potentiels problèmes de violation d'accès mémoire avec Unsafe (voir section _Analysis_)

* Utilisation d'Unsafe par les grands groupes :
** http://www.inf.usi.ch/lanza/Downloads/Mast2015a.pdf +
Etude complète, présente également les risques liés à l'utilisation d'Unsafe +
A fait l'objet d'un talk en 2015 : [https://www.youtube.com/watch?v=_mIBxVbAT_Y|Use at Your Own Risk: The Java Unsafe API in the Wild]

* Fonctionnalités d'Unsafe :
** http://mydailyjava.blogspot.fr/2013/12/sunmiscunsafe.html
** http://howtodoinjava.com/core-java/related-concepts/usage-of-class-sun-misc-unsafe/
** https://dzone.com/articles/understanding-sunmiscunsafe
** http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/

* Les alternatives à venir pour Unsafe :
** Variables Handles : http://openjdk.java.net/jeps/193 +
Attention ! Les Var Handles ne représentent qu'un remplacement *partiel* de Unsafe. +
[quote, Hazelcast - Christoph Engelbert]
____
Variable Handles or (VarHandles) are not meant to be a full sun.misc.Unsafe replacement but to replace the memory access features.
____

Java Intrinsics :

* http://vanillajava.blogspot.fr/2012/11/java-intrinsics-and-performance.html (blog de Peter Lawrey) +
Contient une comparaison des perfs entre une méthode intrinsified, Integer.bitCount(), et la copie de son code, exécutée telle quelle (rapport de 6 en faveur de la version intrinsified).
* https://en.wikipedia.org/wiki/Intrinsic_function
* https://mechanical-sympathy.blogspot.fr/2012/07/native-cc-like-performance-for-java.html
* http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8076112 +
Contient une bonne définition des intrinsics : _Intrinsics are high optimized (mostly hand written assembler) code which are used instead of normal JIT compiled code._
* fonctionnement des intrinsics : https://shipilev.net/blog/2016/arrays-wisdom-ancients/ +
Voir la javadoc de l'annotation `HotSpotIntrinsicCandidate`
* fonctionnement des intrinsics : https://www.infoq.com/articles/OpenJDK-HotSpot-What-the-JIT
Voir la section _Intrinsics_
* fonctionnement des intrinsics : http://psy-lob-saw.blogspot.fr/2012/10/java-intrinsics-are-not-jni-calls.html
* Fonctionnement des intrinsics : http://bad-concurrency.blogspot.fr/2012/08/arithmetic-overflow-and-intrinsics.html +
Contient la meilleure explication que j'ai trouvé sur le fonctionnement des intrinsics (voir la section _How it Works_) +
Propose également un benchmark comparatif autour de Integer.bitCount()
* Quand les intrinsics sont-ils utilisés ? http://stackoverflow.com/questions/23041036/why-do-java-intrinsic-functions-still-have-code +
-> *systématiquement*, dès lors que le code assembleur optimisé est disponible (varie suivant les JVMs !) +
Voir cet post de SO pour confirmation : http://stackoverflow.com/questions/15085294/java-lang-math-log-replaced-by-intrinsic-call-why-not-java-lang-math-exp

What librairies use Unsafe?

* Objenesis[http://objenesis.org/|site][https://github.com/easymock/objenesis|code]: to instantiate objects by various ways

